# RepliBuild API

## 🎯 Three Core Workflows

RepliBuild is optimized for **three production workflows**. Everything else is internal.

### 1. **Julia Project Initialization → C++ Bindings**
The main workflow for wrapping C++ code in Julia:

```julia
using RepliBuild

# Step 1: Initialize project
RepliBuild.init("my_cpp_project")
cd("my_cpp_project")

# Add your C++ files to src/, headers to include/

# Step 2: Discover project structure and generate config
RepliBuild.discover()  # Scans, walks AST, generates replibuild.toml

# Step 3: Compile C++ → Julia bindings
RepliBuild.compile()   # Produces .jl modules with ccall bindings

# Done! Your Julia bindings are in julia/
```

**What happens:**
- `discover()`: Scans for .cpp/.h files, analyzes dependencies with AST walker, detects LLVM toolchain
- `compile()`: Compiles C++ → LLVM IR → shared library (.so), generates Julia wrapper with ccall bindings
- Output: Julia module that `using MyModule` works out of the box

---

### 2. **CMake Import → Julia Bindings**
Import existing CMake projects:

```julia
using RepliBuild

# Import CMake project (generates replibuild.toml from CMakeLists.txt)
RepliBuild.import_cmake("path/to/CMakeLists.txt", target="mylib")

# Compile as usual
RepliBuild.compile()
```

### 3. **Binary Wrapping** (Alternative: Wrap Existing .so/.dll)
If you already have a compiled library:

```julia
using RepliBuild

# Initialize wrapper project
RepliBuild.init("my_wrappers", type=:binary)

# Wrap existing binary
RepliBuild.wrap_binary("/usr/lib/libcrypto.so")

# Or wrap all binaries in a config
RepliBuild.wrap("wrapper_config.toml")
```

**What happens:**
- Scans binary symbols with `nm` / `objdump`
- Generates Julia ccall wrappers
- Handles name mangling, type inference
- Creates testable Julia modules

---

## 🏗️ Production Architecture

### Core Modules (Keep These)
```
LLVMEnvironment     → LLVM/Clang toolchain isolation
ConfigurationManager → TOML config parsing & validation
Discovery           → Project scanning, AST walking, tool detection
LLVMake             → C++ → IR → .so compilation pipeline
ClangJLBridge       → Clang.jl integration for advanced bindings
JuliaWrapItUp       → Binary → Julia wrapper generation
CMakeParser         → CMake → TOML conversion
BuildBridge         → Command execution with error learning
ErrorLearning       → SQLite-based error pattern DB (production-ready)
DaemonManager       → Optional daemon orchestration (4 daemons)
```

### Daemon System (Optional Performance Layer)
**4 Production Daemons:**
- `discovery_daemon` (port 3001): File scanning, AST caching
- `setup_daemon` (port 3002): Config generation
- `compilation_daemon` (port 3003): Parallel C++ compilation
- `orchestrator_daemon` (port 3004): Pipeline coordination

**Start/stop:**
```julia
RepliBuild.start_daemons()  # Background persistent processes
RepliBuild.stop_daemons()   # Graceful shutdown
RepliBuild.daemon_status()  # Check health
```

## 📦 Configuration Format

`replibuild.toml` structure (auto-generated by `discover()`):

```toml
[project]
name = "MyProject"
uuid = "..." # Auto-generated marker
root = "."

[paths]
source = "src"
output = "julia"
build = "build"

[llvm]
# Auto-detected by LLVMEnvironment
root = "/path/to/llvm"  # Optional override
tools = { clang++ = "...", llvm-config = "..." }

[compile]
include_dirs = ["include", "src"]  # Auto-detected
lib_dirs = []
libraries = []
flags = ["-std=c++17", "-fPIC"]

[bindings]
style = "simple"  # or "clangjl" for Clang.jl integration
exclude_patterns = ["^test_", ".*_internal"]
```

**Edit this manually** or let `discover()` regenerate.

---

## 🔧 Advanced API

### Toolchain Management
```julia
# Get current LLVM toolchain
toolchain = RepliBuild.get_toolchain()

# Verify it works
RepliBuild.verify_toolchain()

# Print details
RepliBuild.print_toolchain_info()

# Run code with specific LLVM environment
RepliBuild.with_llvm_env() do
    # Code here uses isolated LLVM
end
```

# Verifies all tools and libraries available to the enviroment
```julia 
RepliBuild.verify_toolchain()

       # Print details
🔍 Verifying LLVM Toolchain...
  ✅ clang++
  ✅ llvm-config
  ✅ llvm-link
  ✅ opt
  ✅ llc

🧪 Testing clang++...
  ✅ clang++ is functional
     clang version 20.1.8

🧪 Testing llvm-config...
  ✅ llvm-config is functional
     Version: 20.1.8

✅ LLVM Toolchain verification PASSED
true

julia> RepliBuild.print_toolchain_info()

       # Run code with specific LLVM environment
======================================================================
LLVM Toolchain Information
======================================================================

🎯 Source: system

📁 Paths:
   Root:       /usr
   Bin:        /usr/bin
   Lib:        /usr/lib
   Include:    /usr/include

📦 Version:
   20.1.8
   Major: 20
   Minor: 1
   Patch: 8

🔧 Tools: (45 available)
   ✓ FileCheck
   ✓ bugpoint
   ✓ clang
   ✓ clang++
   ✓ clang-20
   ✓ clang-check
   ✓ clang-format
   ✓ clang-query
   ✓ clang-refactor
   ✓ clang-repl
   ✓ clang-scan-deps
   ✓ clang-tidy
   ✓ clangd
   ✓ count
   ✓ dsymutil
   ✓ llc
   ✓ lli
   ✓ llvm-ar
   ✓ llvm-as
   ✓ llvm-config
   ✓ llvm-cov
   ✓ llvm-debuginfod
   ✓ llvm-debuginfod-find
   ✓ llvm-dis
   ✓ llvm-dwarfdump
   ✓ llvm-extract
   ✓ llvm-link
   ✓ llvm-lto
   ✓ llvm-lto2
   ✓ llvm-nm
   ✓ llvm-objdump
   ✓ llvm-opt-report
   ✓ llvm-profdata
   ✓ llvm-profgen
   ✓ llvm-ranlib
   ✓ llvm-readelf
   ✓ llvm-readobj
   ✓ llvm-reduce
   ✓ llvm-size
   ✓ llvm-split
   ✓ llvm-stress
   ✓ llvm-strings
   ✓ llvm-symbolizer
   ✓ not
   ✓ opt

📚 Libraries: (2931 available)
   ✓ .cpython-313-x86_64-linux-gnu
   ✓ 7z
   ✓ ANSI_X3.110
   ✓ ARMSCII-8
   ✓ ASMO_449
   ✓ B
   ✓ BIG5
   ✓ BIG5HKSCS
   ✓ BRF
   ✓ Base64
   ... and 2921 more

🌍 Environment Variables:
   CPATH = /usr/include
   Clang_DIR = /usr/lib
   LD_LIBRARY_PATH = /usr/lib
   LIBRARY_PATH = /usr/lib
   LLVM_DIR = /usr/lib
   LLVM_ROOT = /usr
   PATH = /usr/bin:/home/grim/.juliaup/bin:/usr/local/bin:/usr/bin:...

🔒 Isolation: Enabled
======================================================================
```

### Direct Compilation Control
```julia
using RepliBuild

# Create compiler instance
compiler = RepliBuild.LLVMJuliaCompiler("replibuild.toml")

# Compile specific files
RepliBuild.compile_project(compiler, specific_files=["src/math.cpp"])

# Or compile project with custom settings
config = RepliBuild.CompilerConfig(...)
compiler = RepliBuild.LLVMJuliaCompiler(config)
RepliBuild.compile_project(compiler)
```

### Binding Generation Options
```julia
# Use Clang.jl for advanced bindings (better type awareness)
config = TOML.parsefile("replibuild.toml")
lib_path = "julia/libmyproject.so"
headers = ["include/myproject.h"]

RepliBuild.generate_bindings_clangjl(config, lib_path, headers)

# Or from config directly
RepliBuild.generate_from_config("replibuild.toml")
```

---

## 🧪 Testing Workflows

### Test Workflow 1: Simple C++ → Julia
```julia
# Create test project
mkdir("test_math")
cd("test_math")

# Write C++ code
write("src/add.cpp", """
extern "C" int add(int a, int b) {
    return a + b;
}
""")

# Build
using RepliBuild
RepliBuild.init()
RepliBuild.discover()
RepliBuild.compile()

# Use
include("julia/test_math.jl")
using .Test_math
@assert add(2, 3) == 5
```

### Test Workflow 2: CMake Import
```julia
using RepliBuild

RepliBuild.import_cmake("external_project/CMakeLists.txt")
RepliBuild.compile()
```

### Test Workflow 3: Binary Wrap
```julia
using RepliBuild

RepliBuild.init("wrappers", type=:binary)
RepliBuild.wrap_binary("/usr/lib/libm.so")  # System math library
```

---

## 🎯 Summary: What to Use

**90% of users:**
```julia
RepliBuild.init()
RepliBuild.discover()
RepliBuild.compile()
```

**CMake users:** Add `RepliBuild.import_cmake()` before `compile()`

**Binary wrappers:** Use `RepliBuild.wrap_binary()`

**Performance freaks:** Use `RepliBuild.start_daemons()` first

**Everything else:** Internal, don't worry about it.

---
