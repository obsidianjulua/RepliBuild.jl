# RepliBuild API

## ğŸ¯ Three Core Workflows

RepliBuild is optimized for **three production workflows**. Everything else is internal.

### 1. **Julia Project Initialization â†’ C++ Bindings**
The main workflow for wrapping C++ code in Julia:

```julia
using RepliBuild

# Step 1: Initialize project
RepliBuild.init("my_cpp_project")
cd("my_cpp_project")

# Add your C++ files to src/, headers to include/

# Step 2: Discover project structure and generate config
RepliBuild.discover()  # Scans, walks AST, generates replibuild.toml

# Step 3: Compile C++ â†’ Julia bindings
RepliBuild.compile()   # Produces .jl modules with ccall bindings

# Done! Your Julia bindings are in julia/
```

**What happens:**
- `discover()`: Scans for .cpp/.h files, analyzes dependencies with AST walker, detects LLVM toolchain
- `compile()`: Compiles C++ â†’ LLVM IR â†’ shared library (.so), generates Julia wrapper with ccall bindings
- Output: Julia module that `using MyModule` works out of the box

---

### 2. **CMake Import â†’ Julia Bindings**
Import existing CMake projects:

```julia
using RepliBuild

# Import CMake project (generates replibuild.toml from CMakeLists.txt)
RepliBuild.import_cmake("path/to/CMakeLists.txt", target="mylib")

# Compile as usual
RepliBuild.compile()
```

### 3. **Binary Wrapping** (Alternative: Wrap Existing .so/.dll)
If you already have a compiled library:

```julia
using RepliBuild

# Initialize wrapper project
RepliBuild.init("my_wrappers", type=:binary)

# Wrap existing binary
RepliBuild.wrap_binary("/usr/lib/libcrypto.so")

# Or wrap all binaries in a config
RepliBuild.wrap("wrapper_config.toml")
```

**What happens:**
- Scans binary symbols with `nm` / `objdump`
- Generates Julia ccall wrappers
- Handles name mangling, type inference
- Creates testable Julia modules

---

## ğŸ—ï¸ Production Architecture

### Core Modules (Keep These)
```
LLVMEnvironment     â†’ LLVM/Clang toolchain isolation
ConfigurationManager â†’ TOML config parsing & validation
Discovery           â†’ Project scanning, AST walking, tool detection
LLVMake             â†’ C++ â†’ IR â†’ .so compilation pipeline
ClangJLBridge       â†’ Clang.jl integration for advanced bindings
JuliaWrapItUp       â†’ Binary â†’ Julia wrapper generation
CMakeParser         â†’ CMake â†’ TOML conversion
BuildBridge         â†’ Command execution with error learning
ErrorLearning       â†’ SQLite-based error pattern DB (production-ready)
DaemonManager       â†’ Optional daemon orchestration (4 daemons)
```

### Daemon System (Optional Performance Layer)
**4 Production Daemons:**
- `discovery_daemon` (port 3001): File scanning, AST caching
- `setup_daemon` (port 3002): Config generation
- `compilation_daemon` (port 3003): Parallel C++ compilation
- `orchestrator_daemon` (port 3004): Pipeline coordination

**Start/stop:**
```julia
RepliBuild.start_daemons()  # Background persistent processes
RepliBuild.stop_daemons()   # Graceful shutdown
RepliBuild.daemon_status()  # Check health
```

## ğŸ“¦ Configuration Format

`replibuild.toml` structure (auto-generated by `discover()`):

```toml
[project]
name = "MyProject"
uuid = "..." # Auto-generated marker
root = "."

[paths]
source = "src"
output = "julia"
build = "build"

[llvm]
# Auto-detected by LLVMEnvironment
root = "/path/to/llvm"  # Optional override
tools = { clang++ = "...", llvm-config = "..." }

[compile]
include_dirs = ["include", "src"]  # Auto-detected
lib_dirs = []
libraries = []
flags = ["-std=c++17", "-fPIC"]

[bindings]
style = "simple"  # or "clangjl" for Clang.jl integration
exclude_patterns = ["^test_", ".*_internal"]
```

**Edit this manually** or let `discover()` regenerate.

---

## ğŸ”§ Advanced API

### Toolchain Management
```julia
# Get current LLVM toolchain
toolchain = RepliBuild.get_toolchain()

# Verify it works
RepliBuild.verify_toolchain()

# Print details
RepliBuild.print_toolchain_info()

# Run code with specific LLVM environment
RepliBuild.with_llvm_env() do
    # Code here uses isolated LLVM
end
```

# Verifies all tools and libraries available to the enviroment
```julia 
RepliBuild.verify_toolchain()

       # Print details
ğŸ” Verifying LLVM Toolchain...
  âœ… clang++
  âœ… llvm-config
  âœ… llvm-link
  âœ… opt
  âœ… llc

ğŸ§ª Testing clang++...
  âœ… clang++ is functional
     clang version 20.1.8

ğŸ§ª Testing llvm-config...
  âœ… llvm-config is functional
     Version: 20.1.8

âœ… LLVM Toolchain verification PASSED
true

julia> RepliBuild.print_toolchain_info()

       # Run code with specific LLVM environment
======================================================================
LLVM Toolchain Information
======================================================================

ğŸ¯ Source: system

ğŸ“ Paths:
   Root:       /usr
   Bin:        /usr/bin
   Lib:        /usr/lib
   Include:    /usr/include

ğŸ“¦ Version:
   20.1.8
   Major: 20
   Minor: 1
   Patch: 8

ğŸ”§ Tools: (45 available)
   âœ“ FileCheck
   âœ“ bugpoint
   âœ“ clang
   âœ“ clang++
   âœ“ clang-20
   âœ“ clang-check
   âœ“ clang-format
   âœ“ clang-query
   âœ“ clang-refactor
   âœ“ clang-repl
   âœ“ clang-scan-deps
   âœ“ clang-tidy
   âœ“ clangd
   âœ“ count
   âœ“ dsymutil
   âœ“ llc
   âœ“ lli
   âœ“ llvm-ar
   âœ“ llvm-as
   âœ“ llvm-config
   âœ“ llvm-cov
   âœ“ llvm-debuginfod
   âœ“ llvm-debuginfod-find
   âœ“ llvm-dis
   âœ“ llvm-dwarfdump
   âœ“ llvm-extract
   âœ“ llvm-link
   âœ“ llvm-lto
   âœ“ llvm-lto2
   âœ“ llvm-nm
   âœ“ llvm-objdump
   âœ“ llvm-opt-report
   âœ“ llvm-profdata
   âœ“ llvm-profgen
   âœ“ llvm-ranlib
   âœ“ llvm-readelf
   âœ“ llvm-readobj
   âœ“ llvm-reduce
   âœ“ llvm-size
   âœ“ llvm-split
   âœ“ llvm-stress
   âœ“ llvm-strings
   âœ“ llvm-symbolizer
   âœ“ not
   âœ“ opt

ğŸ“š Libraries: (2931 available)
   âœ“ .cpython-313-x86_64-linux-gnu
   âœ“ 7z
   âœ“ ANSI_X3.110
   âœ“ ARMSCII-8
   âœ“ ASMO_449
   âœ“ B
   âœ“ BIG5
   âœ“ BIG5HKSCS
   âœ“ BRF
   âœ“ Base64
   ... and 2921 more

ğŸŒ Environment Variables:
   CPATH = /usr/include
   Clang_DIR = /usr/lib
   LD_LIBRARY_PATH = /usr/lib
   LIBRARY_PATH = /usr/lib
   LLVM_DIR = /usr/lib
   LLVM_ROOT = /usr
   PATH = /usr/bin:/home/grim/.juliaup/bin:/usr/local/bin:/usr/bin:...

ğŸ”’ Isolation: Enabled
======================================================================
```

### Direct Compilation Control
```julia
using RepliBuild

# Create compiler instance
compiler = RepliBuild.LLVMJuliaCompiler("replibuild.toml")

# Compile specific files
RepliBuild.compile_project(compiler, specific_files=["src/math.cpp"])

# Or compile project with custom settings
config = RepliBuild.CompilerConfig(...)
compiler = RepliBuild.LLVMJuliaCompiler(config)
RepliBuild.compile_project(compiler)
```

### Binding Generation Options
```julia
# Use Clang.jl for advanced bindings (better type awareness)
config = TOML.parsefile("replibuild.toml")
lib_path = "julia/libmyproject.so"
headers = ["include/myproject.h"]

RepliBuild.generate_bindings_clangjl(config, lib_path, headers)

# Or from config directly
RepliBuild.generate_from_config("replibuild.toml")
```

---

## ğŸ§ª Testing Workflows

### Test Workflow 1: Simple C++ â†’ Julia
```julia
# Create test project
mkdir("test_math")
cd("test_math")

# Write C++ code
write("src/add.cpp", """
extern "C" int add(int a, int b) {
    return a + b;
}
""")

# Build
using RepliBuild
RepliBuild.init()
RepliBuild.discover()
RepliBuild.compile()

# Use
include("julia/test_math.jl")
using .Test_math
@assert add(2, 3) == 5
```

### Test Workflow 2: CMake Import
```julia
using RepliBuild

RepliBuild.import_cmake("external_project/CMakeLists.txt")
RepliBuild.compile()
```

### Test Workflow 3: Binary Wrap
```julia
using RepliBuild

RepliBuild.init("wrappers", type=:binary)
RepliBuild.wrap_binary("/usr/lib/libm.so")  # System math library
```

---

## ğŸ¯ Summary: What to Use

**90% of users:**
```julia
RepliBuild.init()
RepliBuild.discover()
RepliBuild.compile()
```

**CMake users:** Add `RepliBuild.import_cmake()` before `compile()`

**Binary wrappers:** Use `RepliBuild.wrap_binary()`

**Performance freaks:** Use `RepliBuild.start_daemons()` first

**Everything else:** Internal, don't worry about it.

---
