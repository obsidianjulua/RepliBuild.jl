#!/usr/bin/env julia
# ModuleTemplateGenerator.jl - Generate module descriptors for external libraries
# Makes it easy for developers to create their own module definitions

module ModuleTemplateGenerator

using TOML
using Dates

export create_module_template, generate_from_cmake, generate_from_pkg_config

"""
    create_module_template(name::String; output_dir::String=".", kwargs...)

Generate a module template for an external library.

# Arguments
- `name::String`: Module name (e.g., "Qt5", "Boost", "MyLibrary")
- `output_dir::String`: Where to write the .toml file
- `cmake_name::String`: CMake package name (defaults to `name`)
- `jll_package::String`: JLL package name (defaults to "\$(name)_jll")
- `description::String`: Library description
- `components::Vector{String}`: List of library components
- `pkg_config::String`: pkg-config name for system fallback

# Examples
```julia
# Simple library
create_module_template("Zlib")

# Library with components
create_module_template("Qt5",
    components=["Core", "Widgets", "Network"],
    description="Qt5 GUI framework")

# Custom JLL mapping
create_module_template("PNG",
    jll_package="libpng_jll",
    pkg_config="libpng16")
```
"""
function create_module_template(name::String;
                               output_dir::String=".",
                               cmake_name::String=name,
                               jll_package::String="$(name)_jll",
                               description::String="",
                               components::Vector{String}=String[],
                               pkg_config::String=lowercase(name),
                               version::String="1.0.0",
                               license::String="")

    println("🎨 Creating module template for: $name")

    # Build TOML structure
    data = Dict{String,Any}()

    # Module section
    data["module"] = Dict(
        "name" => name,
        "cmake_name" => cmake_name,
        "description" => isempty(description) ? "Module for $name library" : description,
        "version" => version
    )

    # Resolution strategy
    data["resolution"] = Dict(
        "prefer" => "jll",
        "fallback" => ["system"]
    )

    # JLL section
    data["jll"] = Dict(
        "package" => jll_package,
        "auto_install" => true
    )

    # Components section (if any)
    if !isempty(components)
        data["components"] = Dict{String,Any}()
        for comp in components
            # Try to guess JLL export name
            jll_export = "lib$(name)$(comp)"
            data["components"][comp] = Dict(
                "jll_export" => jll_export,
                "required" => false,
                "description" => "$name $comp component"
            )
        end

        # Add component dependencies (empty, user fills in)
        data["component_deps"] = Dict{String,Any}()
    end

    # System fallback
    data["system"] = Dict(
        "pkg_config" => pkg_config,
        "header_check" => "$(name)/$(name).h",  # Guess, user adjusts
        "search_paths" => [
            "/usr/lib",
            "/usr/local/lib",
            "/opt/$(lowercase(name))"
        ]
    )

    # Flags
    data["flags"] = Dict(
        "compile" => String[],
        "link" => String[],
        "defines" => Dict{String,String}()
    )

    if !isempty(components)
        data["flags"]["per_component"] = Dict{String,Any}()
    end

    # Version constraints
    data["version"] = Dict(
        "minimum" => version,
        "maximum" => "99.99.99",
        "recommended" => version
    )

    # Metadata
    data["metadata"] = Dict(
        "homepage" => "",
        "documentation" => "",
        "license" => license,
        "created" => string(now()),
        "created_by" => "RepliBuild ModuleTemplateGenerator"
    )

    # Write to file
    output_file = joinpath(output_dir, "$(name).toml")
    open(output_file, "w") do io
        # Add header comment
        println(io, "# $name Module - Generated by RepliBuild")
        println(io, "# Created: $(now())")
        println(io, "# Edit this file to customize the module for your needs")
        println(io, "")
        TOML.print(io, data)
    end

    println("✅ Module template created: $output_file")
    println("")
    println("📝 Next steps:")
    println("   1. Edit $output_file")
    println("   2. Verify JLL package name: $(jll_package)")
    println("   3. Adjust component names and exports")
    println("   4. Add compiler/linker flags if needed")
    println("   5. Test with: ModuleRegistry.resolve_module(\"$name\")")

    return output_file
end

"""
    generate_from_pkg_config(pkg_name::String; output_dir::String=".")

Generate a module from pkg-config information.
"""
function generate_from_pkg_config(pkg_name::String; output_dir::String=".")
    try
        if !success(`which pkg-config`)
            error("pkg-config not found on system")
        end

        # Query pkg-config
        name_output = try
            strip(read(`pkg-config --print-provides $pkg_name`, String))
        catch
            pkg_name
        end

        version_output = try
            strip(read(`pkg-config --modversion $pkg_name`, String))
        catch
            "unknown"
        end

        cflags = try
            strip(read(`pkg-config --cflags $pkg_name`, String))
        catch
            ""
        end

        libs = try
            strip(read(`pkg-config --libs $pkg_name`, String))
        catch
            ""
        end

        println("📦 Discovered from pkg-config:")
        println("   Name: $name_output")
        println("   Version: $version_output")
        println("   CFLAGS: $cflags")
        println("   LIBS: $libs")

        # Parse flags
        compile_flags = String[]
        link_flags = String[]
        include_dirs = String[]
        library_dirs = String[]
        libraries = String[]

        for flag in split(cflags)
            if startswith(flag, "-I")
                push!(include_dirs, flag[3:end])
            elseif startswith(flag, "-D") || startswith(flag, "-f")
                push!(compile_flags, flag)
            end
        end

        for flag in split(libs)
            if startswith(flag, "-L")
                push!(library_dirs, flag[3:end])
            elseif startswith(flag, "-l")
                push!(libraries, flag[3:end])
            else
                push!(link_flags, flag)
            end
        end

        # Create module with discovered info
        module_name = titlecase(split(name_output)[1])

        return create_module_template(
            module_name,
            output_dir=output_dir,
            pkg_config=pkg_name,
            version=String(version_output),
            description="Generated from pkg-config $pkg_name"
        )

    catch e
        @warn "Failed to generate from pkg-config: $pkg_name" exception=e
        println("💡 Tip: Create manually with: create_module_template(\"$pkg_name\")")
        return nothing
    end
end

"""
    generate_from_cmake(find_package_name::String; output_dir::String=".")

Generate a module from CMake find_package() name.
Uses common CMake conventions to guess structure.
"""
function generate_from_cmake(find_package_name::String; output_dir::String=".")
    println("🔨 Generating module from CMake find_package($find_package_name)...")

    # Common CMake naming patterns
    # Qt5 → Qt5::Core, Qt5::Widgets
    # Boost → Boost::system, Boost::filesystem
    # OpenCV → opencv_core, opencv_imgproc

    components = String[]

    # Guess common components based on package name
    if contains(lowercase(find_package_name), "qt")
        components = ["Core", "Gui", "Widgets", "Network"]
    elseif contains(lowercase(find_package_name), "boost")
        components = ["system", "filesystem", "thread", "regex"]
    elseif contains(lowercase(find_package_name), "opencv")
        components = ["core", "imgproc", "highgui", "videoio"]
    end

    return create_module_template(
        find_package_name,
        output_dir=output_dir,
        components=components,
        description="Generated from CMake find_package($find_package_name)"
    )
end

"""
    create_custom_build_module(name::String, git_url::String; output_dir::String=".")

Create a module template for a library that needs custom building.
"""
function create_custom_build_module(name::String, git_url::String;
                                   output_dir::String=".",
                                   git_tag::String="main",
                                   cmake_args::Dict{String,String}=Dict())

    println("⚙️  Creating custom build module for: $name")

    data = Dict{String,Any}()

    # Module section
    data["module"] = Dict(
        "name" => name,
        "cmake_name" => name,
        "description" => "Custom build of $name from source",
        "version" => "custom"
    )

    # Force custom resolution
    data["resolution"] = Dict(
        "prefer" => "custom",
        "fallback" => ["jll", "system"]
    )

    # Custom build section
    data["custom"] = Dict(
        "git_url" => git_url,
        "git_tag" => git_tag,
        "build_script" => "$(lowercase(name))_build.jl",
        "cache_dir" => joinpath(homedir(), ".replibuild", "custom_builds", name)
    )

    if !isempty(cmake_args)
        data["custom"]["cmake_args"] = cmake_args
    end

    # Flags
    data["flags"] = Dict(
        "compile" => String[],
        "link" => String[]
    )

    # Write to file
    output_file = joinpath(output_dir, "$(name).toml")
    open(output_file, "w") do io
        println(io, "# $name Custom Build Module")
        println(io, "# This module builds $name from source")
        println(io, "")
        TOML.print(io, data)
    end

    # Create example build script
    build_script = joinpath(output_dir, "$(lowercase(name))_build.jl")
    open(build_script, "w") do io
        println(io, """
        #!/usr/bin/env julia
        # Custom build script for $name
        # This script is called by RepliBuild when the module needs to be built

        using Pkg

        function build_$(lowercase(name))(source_dir::String, install_dir::String, cmake_args::Dict)
            println("🔨 Building $name from source...")

            # Clone if needed
            if !isdir(source_dir)
                run(`git clone $(git_url) \$source_dir`)
                cd(source_dir)
                run(`git checkout $(git_tag)`)
            end

            # Build
            build_dir = joinpath(source_dir, "build")
            mkpath(build_dir)
            cd(build_dir)

            # Configure
            cmake_cmd = `cmake .. -DCMAKE_INSTALL_PREFIX=\$install_dir`
            for (key, val) in cmake_args
                cmake_cmd = `\$cmake_cmd -D\$key=\$val`
            end
            run(cmake_cmd)

            # Build
            run(`cmake --build . -j\$(Sys.CPU_THREADS)`)

            # Install
            run(`cmake --install .`)

            println("✅ $name built successfully")
            return install_dir
        end

        # Export the build function
        export build_$(lowercase(name))
        """)
    end

    println("✅ Custom build module created: $output_file")
    println("✅ Build script template: $build_script")
    println("")
    println("📝 Next steps:")
    println("   1. Edit the build script: $build_script")
    println("   2. Test build with: include(\"$build_script\"); build_$(lowercase(name))(...)")

    return (output_file, build_script)
end

end # module ModuleTemplateGenerator