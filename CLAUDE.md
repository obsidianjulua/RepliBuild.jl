# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

RepliBuild.jl is a C++ to Julia build orchestration system that compiles C++ code to LLVM IR, generates shared libraries, and automatically creates high-quality Julia bindings. The system uses a three-stage workflow: **discover** → **build** → **wrap**.

**Key Innovation**: RepliBuild extracts DWARF debug information and symbol metadata during compilation to enable automatic, type-safe Julia wrapper generation without manually writing FFI bindings.

## Common Commands

### Development Workflow

```bash
# Run Julia REPL
julia

# Activate package
using Pkg; Pkg.activate(".")

# Run tests (when test files exist)
Pkg.test()

# Build and test a specific file
julia --project=. src/RepliBuild.jl
```

### Using RepliBuild

```julia
# In Julia REPL:
using RepliBuild

# 1. Discover C++ project and generate replibuild.toml
toml_path = RepliBuild.discover()

# 2. Compile C++ → library (.so/.dylib/.dll)
RepliBuild.build(toml_path)

# 3. Generate Julia wrappers
RepliBuild.wrap(toml_path)

# Or chain all steps together:
RepliBuild.discover(build=true, wrap=true)

# Clean build artifacts
RepliBuild.clean()

# Show project status
RepliBuild.info()
```

## Architecture Overview

### Core Pipeline

1. **Discovery** ([Discovery.jl](src/Discovery.jl:1))
   - Scans C++ project directory for sources and headers
   - Detects binaries and include paths
   - Walks AST dependencies using Clang
   - Generates `replibuild.toml` configuration

2. **Compilation** ([Compiler.jl](src/Compiler.jl:1))
   - Compiles C++ files to LLVM IR (`.ll` files)
   - Links and optimizes IR modules
   - Creates shared library using Clang++
   - **CRITICAL**: Extracts DWARF debug info and symbol metadata for wrapping

3. **Wrapper Generation** ([Wrapper.jl](src/Wrapper.jl:1))
   - Three-tier system: Basic (symbol-only) → Advanced (header-aware) → Introspective (metadata-rich)
   - Generates Julia `ccall` wrappers with proper type mappings
   - Creates struct definitions and enum types from DWARF info
   - **Always prefers Tier 3 (Introspective)** when compilation metadata exists

### Configuration System

All configuration is centralized in [ConfigurationManager.jl](src/ConfigurationManager.jl:1):

- **Immutable structs**: `RepliBuildConfig` contains nested configs (ProjectConfig, CompileConfig, etc.)
- **Single source of truth**: All TOML parsing happens in ConfigurationManager
- **Config file**: `replibuild.toml` in project root (auto-generated by discovery)
- Other modules receive pre-parsed `RepliBuildConfig` structs, never parse TOML directly

### Supporting Modules

- **BuildBridge.jl**: Executes LLVM toolchain commands (clang++, llvm-link, opt, nm, readelf)
- **LLVMEnvironment.jl**: Manages LLVM toolchain detection and initialization
- **ASTWalker.jl**: Dependency analysis using Clang AST parsing
- **ClangJLBridge.jl**: Integration with Clang.jl for header-based wrapping
- **CMakeParser.jl**: Parses CMake projects (legacy, less important)
- **RepliBuildPaths.jl**: Path utilities and directory management

## Key Implementation Details

### DWARF Metadata Extraction

The core of RepliBuild's automatic wrapping capability is in [Compiler.jl:extract_dwarf_return_types](src/Compiler.jl:643):

- Parses `readelf --debug-dump=info` output to extract:
  - Function signatures with return types and parameters
  - Struct/class member layouts
  - Enum definitions with enumerator values
  - Type references (pointers, const, references, arrays)
- Resolves type chains (e.g., `const T*` → pointer to const base type)
- Maps C++ types to Julia types comprehensively

**IMPORTANT**: Always compile with `-g` flag to generate DWARF debug information. This is automatically added in [Compiler.jl:compile_single_to_ir](src/Compiler.jl:68-70).

### Type System

Type mapping is handled in [Wrapper.jl:create_type_registry](src/Wrapper.jl:83):

- **Base types**: Complete C/C++ primitive type mappings (int, float, bool, etc.)
- **Fixed-width types**: int8_t → Int8, uint32_t → UInt32, etc.
- **Pointers**: `char*` → `Cstring`, `T*` → `Ptr{T}`
- **STL types**: std::string → String, std::vector<T> → Vector{T}
- **Structs/Enums**: Extracted from DWARF and generated as Julia types

Type strictness is configurable via `config.types.strictness`:
- `:strict` - Error on unmapped types
- `:warn` - Warn and fallback to `Any`
- `:permissive` - Silent `Any` fallback

### Incremental Compilation

[Compiler.jl:needs_recompile](src/Compiler.jl:29) implements mtime-based caching:
- Compares source file modification time against IR file
- Skips recompilation if IR is newer than source
- Cache can be disabled via `config.cache.enabled = false`

### Parallel Compilation

When `config.compile.parallel = true` and multiple source files exist:
- Uses `Threads.@threads` for parallel compilation ([Compiler.jl:141](src/Compiler.jl:141))
- Number of threads: `Threads.nthreads()` (set via `JULIA_NUM_THREADS`)
- Failures are collected and reported together

## Important Workflows

### Adding a New Feature to Discovery

1. Modify [Discovery.jl](src/Discovery.jl:1) to detect your feature
2. Update [ConfigurationManager.jl](src/ConfigurationManager.jl:1) to add config fields if needed
3. Modify [Discovery.jl:generate_config](src/Discovery.jl:488) to populate the config
4. Save config to TOML in the appropriate section

### Modifying Wrapper Generation

1. **For type mappings**: Edit [Wrapper.jl:create_type_registry](src/Wrapper.jl:83) base_types or stl_types
2. **For DWARF parsing**: Edit [Compiler.jl:extract_dwarf_return_types](src/Compiler.jl:643)
3. **For code generation**: Edit [Wrapper.jl:generate_introspective_module](src/Wrapper.jl:1267)
4. **IMPORTANT**: Wrapper generation always prefers introspective tier when metadata exists

### Extending Compiler Capabilities

1. **New compilation flag**: Add to [ConfigurationManager.jl:parse_compile_config](src/ConfigurationManager.jl:213)
2. **New LLVM tool**: Add to [BuildBridge.jl](src/BuildBridge.jl:1) tool execution
3. **New optimization**: Modify [Compiler.jl:link_optimize_ir](src/Compiler.jl:174)

## File Organization

```
src/
├── RepliBuild.jl           # Main module, public API (discover, build, wrap, clean, info)
├── ConfigurationManager.jl # Configuration management (TOML parsing, immutable configs)
├── Discovery.jl            # C++ project scanning and config generation
├── Compiler.jl             # C++ → IR → library compilation + metadata extraction
├── Wrapper.jl              # Julia binding generation (3-tier system)
├── BuildBridge.jl          # LLVM toolchain execution layer
├── LLVMEnvironment.jl      # LLVM toolchain detection and management
├── ASTWalker.jl            # Clang-based dependency analysis
├── ClangJLBridge.jl        # Clang.jl integration for header parsing
├── CMakeParser.jl          # CMake project parsing (legacy)
└── RepliBuildPaths.jl      # Path utilities
```

## Configuration File Structure

`replibuild.toml` sections:
- `[project]` - name, root, uuid
- `[paths]` - source, include, output, build, cache
- `[discovery]` - enabled, walk_dependencies, ignore_patterns
- `[compile]` - source_files, include_dirs, flags, defines, parallel
- `[link]` - optimization_level, enable_lto, link_libraries
- `[binary]` - type (:shared/:static/:executable), output_name
- `[wrap]` - enabled, style (:clang/:basic), module_name
- `[llvm]` - toolchain (:auto/:system/:jll), version
- `[workflow]` - stages (array of symbols)
- `[cache]` - enabled, directory
- `[types]` - strictness, allow_unknown_structs, custom type mappings

## Testing Strategy

When developing features:
1. Test discovery with a sample C++ project
2. Verify `replibuild.toml` is generated correctly
3. Test compilation produces `.so` file and `compilation_metadata.json`
4. Verify wrapper generation produces valid Julia code
5. Test that generated wrapper loads and calls functions correctly

## Common Pitfalls

1. **Missing -g flag**: Wrapper quality degrades without DWARF info (automatically added)
2. **TOML parsing**: Only do TOML parsing in ConfigurationManager, never in other modules
3. **Config immutability**: Use `with_*` helper functions to create modified configs, never mutate
4. **Metadata dependency**: Wrapper generation requires `compilation_metadata.json` from build step
5. **Path handling**: Always use `abspath()` for file paths, relative paths are relative to config file location

## LLVM Toolchain

RepliBuild requires LLVM toolchain (clang++, llvm-link, opt, nm, readelf):
- **Detection**: Automatic via [LLVMEnvironment.jl:init_toolchain](src/LLVMEnvironment.jl:1)
- **Modes**: system (PATH), custom (user-specified), JLL packages
- **Version**: Tested with LLVM 14-19

## Debugging

- **Verbose output**: RepliBuild prints progress for all major steps
- **Metadata inspection**: Check `julia/compilation_metadata.json` for extracted symbol info
- **IR inspection**: Check `build/*.ll` files for LLVM IR
- **DWARF info**: Run `readelf --debug-dump=info julia/lib*.so` manually
- **Symbol info**: Run `nm -D --demangle julia/lib*.so` manually
